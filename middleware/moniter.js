var cluster = require('cluster')var os = require('os')var EventEmitter = require('events').EventEmittervar util = require("util")var exec = require('child_process').execvar spawn = require('child_process').spawnconst TOTALMEM  = os.totalmem()function getOSMemUsage(){    return os.freemem()/TOTALMEM}function getOSCpuUsage(){    var cpus = os.cpus    var numCPUs = cpus.length    for(var i=0; i<numCPUs; i++) {            }}function getProcessMemUsage(proc){    var pid = proc.pid    return proc.memoryUsage()}function getProcessCpuUsage(proc){    var pid = proc.pid}// Returns an array containing the 1, 5, and 15 minute load averages,// load averages is for the entire systemfunction getLoadavg(){    return os.loadavg()}function getProcessInfo(param, callback) {    if (process.platform === 'windows') return;    var pid = param.pid;    var psCommand = "ps auxw | grep " + pid + " | grep -v 'grep'";    exec(psCommand, function(err, output) {        if (err) {            return callback(err, null);        }        var outArray = output.toString().replace(/^\s+|\s+$/g,"").split(/\s+/);        var outValueArray = [];        for (var i = 0; i < outArray.length; i++) {            if ((!isNaN(outArray[i]))) {                outValueArray.push(outArray[i]);            }        }        var ps = {            pid: pid,            usr: 0,            sys: 0,            gue: 0        };        ps.cpuAvg = outValueArray[1];        ps.memAvg = outValueArray[2];        ps.vsz = outValueArray[3];        ps.rss = outValueArray[4];        // clear and reuse        outValueArray = [];        var pidstatCommand = "pidstat -p " + pid;        exec(pidstatCommand, function(err, output) {            if (err) {                console.error(err);                return callback(null, ps);            }            var outArray = output.toString().replace(/^\s+|\s+$/g,"").split(/\s+/);            for (var i = 0; i < outArray.length; i++) {                if ((!isNaN(outArray[i]))) {                    outValueArray.push(outArray[i]);                }            }            ps.usr = outValueArray[1];            ps.sys = outValueArray[2];            ps.gue = outValueArray[3];            callback(null, ps);        });    });}function Monitor(options){    EventEmitter.call(this);    this.options = options;    var that = this;    this.intervalId  = setInterval(function(){        if(options.os){            that.os()        }        if(options.process){            that.process()        }    }, options.interval);}util.inherits(MyStream, EventEmitter);Monitor.prototype.os = function() {    this.emit("os", data);}Monitor.prototype.process = function(){    getProcessInfo(this.options, function(data){        this.emit("process", data)    })}Monitor.prototype.stop = function(){    if(this.intervalId){        clearInterval(this.intervalId)    }}exports.Monitor = Monitor;